Project 2

When tackling the testing approach, I first had to really dig into the requirements. I broke things down by first looking at what the program needed to do and creating a test to look at when I wanted to validate correctly input data. So, I would look at if the input was expecting a 10-digit number, then I would validate that the 10-digit number was accurate. Then I would take an approach to look at outliers from the expected input. I would look at if the input was null or blank, I would look at if the number was less than 10 digits and then look at if the number was greater than 10 digits. This was the approach I took to all the requirements when creating the J unit test cases. I needed to first look at validating expected results, then examine outliers that were defined in the criteria of the documents.
	When I took this approach, I should have tested each individual test case as I wrote it, but once I knew the code was valid and that it had no errors, I moved on to the next requirement. One problem with how I approached this was I don’t think I did it the intended way. I wrote the class program first. I created the constructor, the setters and the getters. Once I had this down, writing the J unit tests was easier because I already knew what the code was and didn’t have to keep looking back to test it. I turned them in along with the milestone assignments thinking that was what was expected but looking at the general discussion, I think that wasn’t how I was supposed to approach the problem. I think the professor wanted me to submit the J unit testing first then project one was when I was supposed to write the classes. I did, however, know it was effective because I ran the test and didn’t submit until I passed all the tests. I ensured that each test was covered 100% before I submitted it. I ensured my code was technically sound by addressing all the errors first and then ensuring that if outliers were entered, that it would handle them appropriately. I don’t really have an example of this because I addressed all those issues. I ensured it was efficient by not creating unnecessary libraries or tables. I only created a map so it would be virtually made and hold the data until the test was over. An example of this is from the AppointmentService class on line 13, I created a private map.
	I broke my testing out into a couple techniques. I used Black Box Testing, and I also used Dynamic Testing methods, and I guess J unit might be considered Regression Testing. Most of the time I used black box testing because I broke my testing up into valid and invalid inputs from the user. Because my criteria define specifically what I was looking for I was able to know what I was expecting from the user and anything else that fell outside of that was considered an outlier and I created test scenarios for them. I used Dynamic testing because there were times when I wasn’t getting the results I was expecting, so I put breaks in the code to follow it step by step and ensure that I was going into the correct statements. Since J unit testing might be considered automation testing, I guess I was using that to validate my code, but I was more so using it to test whether I completed my program.
	I didn’t use white box testing because I don’t think that I wanted the code to go through every line as that probably won’t be very efficient. I didn’t use gray box testing since I view this project as only getting input from a user and validating the input, I had no need to focus on an output from the user making this testing method unnecessary. I didn’t use exploratory testing because J unit was new for me, and I probably shouldn’t trust my intuition or experience just yet (better to be more thorough). If I was a senior or if I was very familiar with the project, then I could see me partially using this method. I didn’t use ad hoc testing because I don’t want to do random testing, I want to ensure each input was either going to be valid or invalid. Even if there were 10’s of thousands of lines of code I still wouldn’t use this method. The only time I could see myself using this method was a very last testing method and I just wanted to doublecheck that it still worked correctly before submitting it. I didn’t use risk-based testing because I wanted it all to be working correctly, not just 80% or greater. I could see myself using this method if I was under more of a time crunch or tight deadline, but not for this. I didn’t use static testing because it was trained in me to keep compiling the code often or fix problems as they come up to catch errors and ensure they don’t snowball. Some errors might be harder to find this way. If I was writing this code on a pen and paper, I could understand needing to use this method but not for this project.
	For this project I approach with caution when creating the class. I wanted to make sure that what I was creating was going to meet the criteria that were needed for this project. I had to go back a couple times and re-edit things, or I realized after making the J unit that I forgot the setters and had to go back and add them in. Getting the imports correct was something a little tricky for me because when I looked at the hints in the general discussion and just copied and pasted those but realized that the virtual lab environment wasn’t recognizing all the imports. I’m always a little bit unsure about this area of coding so I had to do a lot of research and ask questions in the general chat to understand what was wrong. Once I transferred to a more updated eclipse on my computer the problems went away. And I found that some of them I didn’t need for how I had designed my code. I skipped this issue and went along with doing the rest of the code because I knew I would need to do a bit more digging to solve these issues. 
	Bias is a problem if the coder is also responsible for testing which is why I think the two should be separated. In a perfect world the code should be approached again with an unbiased and unassuming perspective to ensure that everything was tackled correctly. I know at my last job when I coded, I had to do the initial testing to get the code to compile, then the developer testing. I would have normally passed it along to a SME (subject matter expert) and they would have done their own testing on the code. Sometimes a fresh perspective can find problems that you as the developer didn’t anticipate. 
	Discipline is something that I feel takes extra effort. I can recall a documentation project that I was on where I had to review my peers’ work and realized they were simply doing copy and paste work and not really adding what the project was looking for. I found I had to do a lot of editing on their specific work to get each thing they turned in up to standards. I feel like this can be applied to writing code as well. Because I’ve been on the receiving end, I know that if I cut corners, I’m just kicking the work down the line to the next person and making things un-necessarily harder than they need to be.
